# Предсказание через подсекции для ускорения обработки

## Проблема

При обработке больших WSI изображений обработка всей секции может занимать много времени. Например:
- Секция с 2 кусками (2.png) - огромные размеры, медленная обработка
- Секция с 6 кусками (6.png) - меньшие размеры, обрабатывается в 3-4 раза быстрее

Внутри секции с индексом 0 часто есть явно выраженное разбиение на еще меньшие куски (подсекции). Если обрабатывать эти подсекции отдельно, можно значительно ускорить обработку.

## Решение

Метод `predict_section_via_subsections` позволяет обрабатывать секцию через подсекции:

1. **Автоматическое разбиение**: Подсекции автоматически определяются из структуры ткани
2. **Параллельная обработка**: Каждая подсекция обрабатывается независимо (можно распараллелить)
3. **Автоматическая дедупликация**: Дубликаты в областях пересечения подсекций автоматически удаляются через NMS и merge

## Использование

### Базовый пример

```python
from scale import wsi, predict, model_config

# Создаем WSI объект с автоматическим определением подсекций
wsi_obj = wsi.WSI(
    wsi_path="./wsi/17_hp_S008__20240820_084008.tiff",
    num_sections=6,  # Находим 6 секций
    num_subsections=None  # Автоматически определяем подсекции
)

# Загружаем модели
model_configs = model_config.create_model_configs()
postprocess_settings = model_config.get_postprocess_settings()

# Создаем предиктор
predictor = predict.WSIPredictor(
    wsi_obj,
    model_configs,
    postprocess_settings,
    overlap_ratio=0.2
)

# Обрабатываем секцию 0 через подсекции (быстрее)
predictions = predictor.predict_section_via_subsections(section_index=0)

# Или обычным способом (медленнее, но то же самое)
predictions_standard = predictor.predict_section(section_index=0)
```

### Сравнение производительности

```python
import time

# Обычный метод
start = time.time()
preds_standard = predictor.predict_section(0)
time_standard = time.time() - start

# Через подсекции
start = time.time()
preds_subsections = predictor.predict_section_via_subsections(0)
time_subsections = time.time() - start

print(f"Ускорение: {time_standard / time_subsections:.2f}x")
```

## Как это работает

### 1. Определение подсекций

Подсекции определяются автоматически из структуры ткани:
- Находятся отдельные крупные кусочки ткани внутри секции
- Если подсекции пересекаются, они разделяются линией (разделителем)
- Разделители сохраняются для правильной фильтрации дубликатов

### 2. Обработка подсекций

Каждая подсекция обрабатывается независимо:
- Используется скользящее окно с перекрытием (как в обычном методе)
- Предикты собираются из всех подсекций
- Применяется постобработка (NMS и merge) для удаления дубликатов

### 3. Фильтрация дубликатов

В областях пересечения подсекций могут появляться дубликаты:
- **NMS (Non-Maximum Suppression)**: Удаляет перекрывающиеся предикты с меньшей уверенностью
- **Merge по coverage**: Объединяет предикты с высоким перекрытием

## Преимущества

1. **Ускорение**: Обработка меньших подсекций быстрее, чем обработка всей секции
2. **Параллелизация**: Подсекции можно обрабатывать параллельно
3. **Точность**: Результаты идентичны обычному методу благодаря дедупликации
4. **Автоматизация**: Не требует ручной настройки границ подсекций

## Ограничения

1. **Требует подсекций**: Если подсекции не найдены, метод автоматически использует обычный `predict_section`
2. **Области пересечения**: В областях пересечения могут быть небольшие различия из-за границ подсекций, но они компенсируются дедупликацией

## Тестирование

Для тестирования используйте скрипт:

```bash
python test/test_predict_via_subsections.py
```

Скрипт сравнивает результаты обычного метода и метода через подсекции, показывая:
- Ускорение обработки
- Разницу в количестве предиктов
- Сохранение результатов для сравнения










