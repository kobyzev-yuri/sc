# KDE и GMM: Объяснение и проблема с визуализацией

## Что такое KDE (Kernel Density Estimation)?

**KDE** - это непараметрический метод оценки плотности распределения данных.

### Как работает KDE:

1. **Берет каждую точку данных** (значение PC1)
2. **Размещает на ней "ядро"** (обычно гауссово распределение)
3. **Суммирует все ядра** - получается сглаженная кривая плотности

### Формула:
```
KDE(x) = (1/n) * Σ K((x - x_i) / h)
```

где:
- `n` - число точек данных
- `K` - ядро (обычно гауссова функция)
- `h` - ширина окна (bandwidth)
- `x_i` - точки данных

### Преимущества KDE:
- ✅ Не требует предположений о форме распределения
- ✅ Адаптируется к данным
- ✅ Показывает реальную форму распределения

### Недостатки KDE:
- ❌ Требует много вычислений для больших данных
- ❌ Чувствителен к выбору bandwidth
- ❌ Не дает параметрическую модель

---

## Что такое GMM (Gaussian Mixture Model)?

**GMM** - это параметрическая модель, которая аппроксимирует распределение как **смесь нескольких гауссовых распределений**.

### Как работает GMM:

1. **Предполагает**, что данные состоят из нескольких "компонентов" (состояний)
2. **Каждый компонент** - это гауссово распределение с параметрами:
   - `μ` (mean) - центр компонента
   - `σ` (std) - ширина компонента
   - `w` (weight) - вес компонента (доля данных)
3. **Суммирует все компоненты** с весами

### Формула:
```
GMM(x) = Σ w_i * N(x | μ_i, σ_i)
```

где:
- `w_i` - вес i-го компонента
- `N(x | μ_i, σ_i)` - гауссова плотность

### Преимущества GMM:
- ✅ Параметрическая модель (можно интерпретировать)
- ✅ Автоматически определяет число компонентов (через BIC)
- ✅ Быстрое вычисление

### Недостатки GMM:
- ❌ Предполагает гауссову форму (может не подходить)
- ❌ Может переобучаться (слишком много компонентов)
- ❌ Проблемы с визуализацией масштаба

---

## Проблема с визуализацией GMM

### Текущая проблема в коде:

В файле `scale/spectral_analysis.py` (строки 444-495) есть проблема с масштабированием:

```python
# Вычисляем общую плотность GMM
gmm_density = np.exp(self.gmm.score_samples(x_grid.reshape(-1, 1)))

# Нормализуем через интеграл
kde_integral = np.trapz(density, x_grid)
gmm_integral = np.trapz(gmm_density, x_grid)
scale_factor = kde_integral / gmm_integral
gmm_density_normalized = gmm_density * scale_factor
```

### Проблемы:

1. **Интеграл по сетке x_grid может быть неточным:**
   - `x_grid` может не покрывать весь диапазон данных
   - Трапециевидное интегрирование может давать ошибки
   - GMM может иметь "хвосты" за пределами x_grid

2. **Отдельные компоненты масштабируются неправильно:**
   ```python
   # Для каждого компонента отдельно:
   gaussian_density = weight * stats.norm.pdf(x_grid, mean, std)
   gaussian_density_scaled = gaussian_density * scale_factor
   ```
   - Проблема: `scale_factor` вычислен для **общей смеси**, но применяется к **отдельным компонентам**
   - Это может давать неадекватные пики

3. **GMM.score_samples возвращает log-плотность:**
   - `np.exp(score_samples)` может давать очень большие или очень маленькие значения
   - При экспоненте могут возникать проблемы с численной стабильностью

### Почему появляются неадекватные пики:

1. **Узкие компоненты:**
   - Если GMM находит компонент с маленьким `σ` (узкий гаусс)
   - Его плотность может быть очень высокой в центре
   - После масштабирования это дает резкий пик

2. **Неправильное масштабирование:**
   - `scale_factor` вычислен для всей смеси
   - Но отдельные компоненты могут иметь разный масштаб
   - Применение одного `scale_factor` ко всем компонентам искажает визуализацию

3. **Проблема с интегралом:**
   - Если `x_grid` не покрывает весь диапазон GMM
   - Интеграл будет занижен
   - `scale_factor` будет завышен
   - Компоненты будут выглядеть слишком высокими

---

## Решение проблемы

### Вариант 1: Правильное масштабирование отдельных компонентов

```python
# Для каждого компонента:
# 1. Вычисляем плотность компонента
gaussian_density = weight * stats.norm.pdf(x_grid, mean, std)

# 2. Масштабируем так, чтобы интеграл совпадал с весом компонента
component_integral = np.trapz(gaussian_density, x_grid)
if component_integral > 0:
    # Нормализуем компонент к его весу
    gaussian_density_normalized = gaussian_density * (weight / component_integral)
else:
    gaussian_density_normalized = gaussian_density

# 3. Масштабируем всю смесь к KDE
total_gmm_integral = np.trapz(total_gmm_density, x_grid)
if total_gmm_integral > 0:
    final_scale = kde_integral / total_gmm_integral
    gaussian_density_final = gaussian_density_normalized * final_scale
```

### Вариант 2: Использовать правильный диапазон для интеграла

```python
# Расширяем x_grid для GMM
gmm_means = self.gmm.means_.flatten()
gmm_stds = np.sqrt(self.gmm.covariances_.flatten())
# Берем диапазон ± 4σ от каждого компонента
x_min_gmm = min(gmm_means - 4 * gmm_stds)
x_max_gmm = max(gmm_means + 4 * gmm_stds)
x_grid_gmm = np.linspace(x_min_gmm, x_max_gmm, num=2000)

# Вычисляем интегралы на расширенной сетке
kde_on_gmm_grid = kde(x_grid_gmm)
gmm_on_gmm_grid = np.exp(self.gmm.score_samples(x_grid_gmm.reshape(-1, 1)))
kde_integral = np.trapz(kde_on_gmm_grid, x_grid_gmm)
gmm_integral = np.trapz(gmm_on_gmm_grid, x_grid_gmm)
```

### Вариант 3: Отключить визуализацию отдельных компонентов

Если отдельные компоненты мешают, можно показывать только общую смесь:

```python
# Показываем только общую смесь GMM
ax1.plot(x_grid, gmm_density_normalized, "m-", linewidth=2, 
         label=f"GMM смесь ({self.gmm.n_components} компонентов)")
# Не показываем отдельные компоненты
```

---

## Рекомендации

1. **Для визуализации использовать только общую смесь GMM** (без отдельных компонентов)
2. **Исправить масштабирование** через правильный расчет интегралов
3. **Расширить x_grid** для более точного интегрирования
4. **Использовать KDE как основной метод** для визуализации, GMM - только для валидации

---

## Сравнение KDE vs GMM

| Характеристика | KDE | GMM |
|---------------|-----|-----|
| **Тип** | Непараметрический | Параметрический |
| **Точность** | Высокая (адаптируется) | Зависит от предположений |
| **Интерпретация** | Сложная | Легкая (компоненты) |
| **Визуализация** | Плавная кривая | Может иметь резкие пики |
| **Вычисление** | Медленнее | Быстрее |
| **Чувствительность** | К bandwidth | К числу компонентов |

**Вывод:** KDE лучше для визуализации, GMM лучше для моделирования и классификации.

